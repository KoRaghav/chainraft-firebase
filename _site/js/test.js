//
// Test script runs on 'test.html' page.
//

let tree;
let parser;

function toggleTestDetails(testId){

    // alert("details"+testId);
    let resultsDivId = "test_result_details_" + testId;
    let testResultsDiv = document.getElementById(resultsDivId);
    let isHidden = testResultsDiv.getAttribute("hidden");
    // Hide.
    if(isHidden===null){
        testResultsDiv.setAttribute("hidden", true);
    } else{
        // Unhide.
        testResultsDiv.removeAttribute("hidden");
    }
    console.log(isHidden);

}

// Do two arrays (treated as sets) contain the same elements.
function arrEq(a1,a2){
    let a1Uniq = _.uniqWith(a1, _.isEqual)
    let a2Uniq = _.uniqWith(a2, _.isEqual)

    let sameSize = a1Uniq.length === a2Uniq.length;
    let sameEls = _.every(a1Uniq, (s) => _.find(a2Uniq, t => _.isEqual(s,t)));
    return sameSize && sameEls;
}

// Check equivalence of given state graph and state graph
// generated by given spec.
function testStateGraphEquiv(testId, stateGraph, specPath){

    $.get(specPath).then(specText => {
        let testsDiv = document.getElementById("tests");

        // Show the spec text and test name first.
        let testHeader = document.createElement("h2");
        testHeader.innerText = "Test: " + testId + "";
        // testHeader.style = "cursor:pointer";
        // testHeader.setAttribute("onclick", `toggleTestDetails(\"${testId}\")`);
        testsDiv.appendChild(testHeader);

        tree = null;
        const newTree = parser.parse(specText + "\n", tree);
        
        // Test correct initial states.
        // let initStates = computeInitStates(newTree);
        let reachable = computeReachableStates(newTree);
        // console.log("spec5 init", initStates);
        let reachableTLC = stateGraph["states"].map(s => s["val"]);
        console.log("spec5 reachable:", reachable);
        console.log("spec5 TLC oracle:", reachableTLC);
        console.log("eq:", arrEq(reachable, reachableTLC));
        let areEquiv = arrEq(reachable, reachableTLC);
        console.assert(areEquiv);

        let statusText = (areEquiv ? "PASS &#10003" : "FAIL &#10007");
        let statusColor = areEquiv ? "green" : "red";
        div = document.createElement("div");
        div.innerHTML = statusText;
        div.style = "font-weight: bold; color:" + statusColor;
        testsDiv.appendChild(div);
    })
}

(async () => {

    // Set up parser.
    await TreeSitter.init();
    parser = new TreeSitter();

    const newLanguageName = "tlaplus";
    const url = `${LANGUAGE_BASE_URL}/tree-sitter-${newLanguageName}.wasm`
    let lang = await TreeSitter.Language.load(url);
    parser.setLanguage(lang);

    let tree = null;

    function testStateGen(testId, specText, initExpected, nextExpected){
        let div;

        // Show the spec text and test name first.
        let testHeader = document.createElement("h2");
        testHeader.innerText = "Test: " + testId + "";
        testHeader.style = "cursor:pointer";
        testHeader.setAttribute("onclick", `toggleTestDetails(\"${testId}\")`);
        testsDiv.appendChild(testHeader);

        let detailedResultsDiv = document.createElement("div");
        detailedResultsDiv.id = "test_result_details_" + testId;

        let specCodeDiv = document.createElement("div");
        specCodeDiv.style = "background-color:rgb(230,230,230);width:70%;margin-bottom:15px;";
        let specCode = document.createElement("code");
        specCode.innerText = specText;
        specCodeDiv.appendChild(specCode);
        detailedResultsDiv.appendChild(specCodeDiv);

        tree = null;
        const newTree = parser.parse(specText + "\n", tree);
        
        // Test correct initial states.
        let initStates = computeInitStates(newTree);
        const passInit = arrEq(initExpected, initStates);

        // Print expected initial states.
        div = document.createElement("div");
        div.innerHTML = "<b>Initial states expected:</b>"
        detailedResultsDiv.appendChild(div);
        for(const state of initExpected){
            let stateDiv = document.createElement("div");
            stateDiv.innerText = JSON.stringify(state);
            detailedResultsDiv.appendChild(stateDiv);
        }

        // Print generated initial states.
        div = document.createElement("div");
        div.innerHTML = "<b>Initial states actual:</b>"
        detailedResultsDiv.appendChild(div);
        for(const state of initStates){
            let stateDiv = document.createElement("div");
            stateDiv.innerText = JSON.stringify(state);
            detailedResultsDiv.appendChild(stateDiv);
        }

        // If given expected next states are null, don't check correctness of next states. 
        let passNext;
        if(nextExpected!==null){
            // Test correct next states.
            let nextStates = computeNextStates(newTree, initStates).map(c => c["state"]);
            passNext = arrEq(nextExpected, nextStates);

            // Print expected next states.
            div = document.createElement("div");
            div.innerHTML = "<b>Next states expected:</b>"
            detailedResultsDiv.appendChild(div);
            for(const state of nextExpected){
                let stateDiv = document.createElement("div");
                stateDiv.innerText = JSON.stringify(state);
                detailedResultsDiv.appendChild(stateDiv);
            }

            // Print next states.
            div = document.createElement("div");
            div.innerHTML = "<b>Next states actual:</b>"
            detailedResultsDiv.appendChild(div);
            for(const state of nextStates){
                let stateDiv = document.createElement("div");
                stateDiv.innerText = JSON.stringify(state);
                detailedResultsDiv.appendChild(stateDiv);
            }
        }

        // Append the detailed results and make it hidden by default.
        // TODO: Re-enable hiding test results by default once it can work
        // separately for single tests and all tests.
        detailedResultsDiv.setAttribute("hidden", true);
        testsDiv.appendChild(detailedResultsDiv);

        // Show the outcome of the test (PASS/FAIL).
        let statusText = "Init: " + (passInit ? "PASS &#10003" : "FAIL &#10007");
        let statusColor = passInit ? "green" : "red";
        div = document.createElement("div");
        div.innerHTML = statusText;
        div.style = "font-weight: bold; color:" + statusColor;
        testsDiv.appendChild(div);

        if(nextExpected!==null){
            statusText = "Next: " + (passNext ? "PASS &#10003" : "FAIL &#10007");
            statusColor = passNext ? "green" : "red";
            div = document.createElement("div");
            div.innerHTML = statusText;
            div.style = "font-weight: bold; color:" + statusColor;
            testsDiv.appendChild(div);
        }
    }



let testsDiv = document.getElementById("tests");
let initExpected;
let nextExpected;

function simple_spec1(){
    let spec1 = `----------------------- MODULE Test ------------------------
    VARIABLE x
    Init == x = 1 
    Next == x' = 2
    ====`;
    initExpected = [{x:1}];
    nextExpected = [{"x":1, "x'":2}]
    testStateGen("simple-spec1", spec1, initExpected, nextExpected);
}

function simple_spec2(){
    let spec2 = `----------------------- MODULE Test ------------------------
    VARIABLE x
    Init == x = 1 \\/ x = 2 
    Next == x' = 2
    ====`;
    initExpected = [{x:1}, {x:2}];    
    nextExpected = [{"x":1, "x'":2}]
    testStateGen("simple-spec2", spec2, initExpected, nextExpected);
}

function simple_spec3(){
    let spec3 = `----------------------- MODULE Test ------------------------
    VARIABLE x
    VARIABLE y
    Init == 
        /\\ x = 1 \\/ x = 2 
        /\\ y = 3 \\/ y = 4
    
    Next == x' = 2 /\\ y' = 2
    ====`;
    initExpected = [{x:1,y:3},{x:2,y:3},{x:1,y:4},{x:2,y:4}];
    nextExpected = [
        {"x":1, "y":3, "x'":2, "y'": 2}, 
        {"x":1, "y":4, "x'":2, "y'": 2}, 
        {"x":2, "y":3, "x'":2, "y'": 2}, 
        {"x":2, "y":4, "x'":2, "y'": 2}, 
    ]
    testStateGen("simple-spec3", spec3, initExpected, nextExpected);
}

function simple_spec4(){
    let spec4 = `----------------------- MODULE Test ------------------------
    VARIABLE x
    Init == 
        /\\ x = 1 \\/ x = 2 
    
    Next == x = 1 /\\ x' = 3
    ====`;
    initExpected = [{x:1},{x:2}];
    nextExpected = [
        {"x":1, "x'":3},
    ]
    testStateGen("simple-spec4", spec4, initExpected, nextExpected);
}

function simple_spec4a(){
    let spec4a = `----------------------- MODULE Test ------------------------
    VARIABLE x
    Init == 
        /\\ x = 1 \\/ x = 2 
    
    Next == 
        /\\ x = 1 
        /\\ x' = 3
    ====`;
    initExpected = [{x:1},{x:2}];
    nextExpected = [
        {"x":1, "x'":3},
    ]
    testStateGen("simple-spec4a", spec4a, initExpected, nextExpected);
}

function simple_spec5(){
    let spec5 = `----------------------- MODULE Test ------------------------
    VARIABLE x
    VARIABLE y
    Init == 
        /\\ x = 1 \\/ x = 2 
        /\\ y = 3 \\/ y = 4
    
    Next == x = 1 /\\ x' = 2 /\\ y' = 2
    ====`;
    initExpected = [{x:1,y:3},{x:2,y:3},{x:1,y:4},{x:2,y:4}];
    nextExpected = [
        {"x":1, "y":3, "x'":2, "y'": 2}, 
        {"x":1, "y":4, "x'":2, "y'": 2}, 
    ]
    testStateGen("simple-spec5", spec5, initExpected, nextExpected);
}

function simple_lockserver_nodefs(){
    let speclockserver = `---- MODULE lockserver_nodefs ----
    EXTENDS TLC, Naturals
    
    VARIABLE semaphore
    VARIABLE clientlocks
    
    Init == 
        /\\ semaphore = [i \\in {0,1} |-> TRUE]
        /\\ clientlocks = [i \\in {88,99} |-> {}]
    
    Next == 
        \\/ \\E c \\in {88,99}, s \\in {0,1} : 
            /\\ semaphore[s] = TRUE
            /\\ clientlocks' = [clientlocks EXCEPT ![c] = clientlocks[c] \\cup {s}]
            /\\ semaphore' = [semaphore EXCEPT ![s] = FALSE]
        \\/ \\E c \\in {88,99}, s \\in {0,1} : 
            /\\ s \\in clientlocks[c]
            /\\ clientlocks' = [clientlocks EXCEPT ![c] = clientlocks[c] \\ {s}]
            /\\ semaphore' = [semaphore EXCEPT ![s] = TRUE]
    
    ====`;
    console.log(speclockserver);
    initExpected = [
        {semaphore:{0:true,1:true}, clientlocks:{88:[], 99:[]}}
    ];
    nextExpected = [
        {semaphore: {0:true,1:true}, clientlocks: {88:[], 99:[]}, "semaphore'": {0:false,1:true}, "clientlocks'": {88:[0], 99:[]}},
        {semaphore: {0:true,1:true}, clientlocks: {88:[], 99:[]}, "semaphore'": {0:false,1:true}, "clientlocks'": {88:[], 99:[0]}},
        {semaphore: {0:true,1:true}, clientlocks: {88:[], 99:[]}, "semaphore'": {0:true,1:false}, "clientlocks'": {88:[], 99:[1]}},
        {semaphore: {0:true,1:true}, clientlocks: {88:[], 99:[]}, "semaphore'": {0:true,1:false}, "clientlocks'": {88:[1], 99:[]}},
    ]
    testStateGen("simple-lockserver-nodefs", speclockserver, initExpected, nextExpected);
}

function simple_lockserver_withdefs(){
    let speclockserver = `---- MODULE lockserver_withdefs ----
    EXTENDS TLC, Naturals
    
    VARIABLE semaphore
    VARIABLE clientlocks
    
    Server == {0,1}
    Client == {88,99}

    Init == 
        /\\ semaphore = [i \\in Server |-> TRUE]
        /\\ clientlocks = [i \\in Client |-> {}]
    
    Next == 
        \\/ \\E c \\in Client, s \\in Server : 
            /\\ semaphore[s] = TRUE
            /\\ clientlocks' = [clientlocks EXCEPT ![c] = clientlocks[c] \\cup {s}]
            /\\ semaphore' = [semaphore EXCEPT ![s] = FALSE]
        \\/ \\E c \\in Client, s \\in Server : 
            /\\ s \\in clientlocks[c]
            /\\ clientlocks' = [clientlocks EXCEPT ![c] = clientlocks[c] \\ {s}]
            /\\ semaphore' = [semaphore EXCEPT ![s] = TRUE]
    
    ====`;
    console.log(speclockserver);
    initExpected = [
        {semaphore:{0:true,1:true}, clientlocks:{88:[], 99:[]}}
    ];
    nextExpected = [
        {semaphore: {0:true,1:true}, clientlocks: {88:[], 99:[]}, "semaphore'": {0:false,1:true}, "clientlocks'": {88:[0], 99:[]}},
        {semaphore: {0:true,1:true}, clientlocks: {88:[], 99:[]}, "semaphore'": {0:false,1:true}, "clientlocks'": {88:[], 99:[0]}},
        {semaphore: {0:true,1:true}, clientlocks: {88:[], 99:[]}, "semaphore'": {0:true,1:false}, "clientlocks'": {88:[], 99:[1]}},
        {semaphore: {0:true,1:true}, clientlocks: {88:[], 99:[]}, "semaphore'": {0:true,1:false}, "clientlocks'": {88:[1], 99:[]}},
    ]
    testStateGen("simple-lockserver-withdefs", speclockserver, initExpected, nextExpected);
}

// (*
//     /\\ i \\in voteQuorum
//     /\\ currentTerm' = [s \\in {44,55,66} |-> IF s \\in voteQuorum THEN currentTerm[i] + 1 ELSE currentTerm[s]]
//     /\\ state' = [s \\in {44,55,66} |->
//                 IF s = i THEN "Primary"
//                 ELSE IF s \\in voteQuorum THEN "Secondary"
//                 ELSE state[s]]
//     /\\ configTerm' = [configTerm EXCEPT ![i] = currentTerm[i] + 1]
//     /\\ UNCHANGED <<config, configVersion>>  *)


// /\\ i \\in config[i]
// \\E i \\in {44,55,66} : 
        
let specmldr1 = `---- MODULE mldr ----
EXTENDS TLC, Naturals

VARIABLE currentTerm
VARIABLE state
VARIABLE config

Init == 
    /\\ currentTerm = [i \\in {44,55} |-> 0]
    /\\ state       = [i \\in {44,55} |-> "Secondary"]
    /\\ \\E initConfig \\in SUBSET {44,55} : initConfig # {} /\\ config = [i \\in {44,55} |-> initConfig]

Next == 
    \\/ \\E i \\in {44,55} : 
        \\E voteQuorum \\in {S \\in SUBSET config[i] : Cardinality(S) * 2 > Cardinality(config[i])} : 
            /\\ i \\in config[i]
            /\\ i \\in voteQuorum
            /\\ currentTerm' = [s \\in {44,55} |-> IF s \\in voteQuorum THEN currentTerm[i] + 1 ELSE currentTerm[s]]
            /\\ state' = [s \\in {44,55} |-> IF s = i THEN "Primary" ELSE "Secondary"]
            /\\ config' = config

====`;

let mldrInitExpected = [
    {   "currentTerm":{"44":0,"55":0},
        "state":{"44":"Secondary","55":"Secondary"},
        "config":{"44":[44],"55":[44]}
    },
    {   "currentTerm":{"44":0,"55":0},
        "state":{"44":"Secondary","55":"Secondary"},
        "config":{"44":[44,55],"55":[44,55]}
    },
    {   "currentTerm":{"44":0,"55":0},
        "state":{"44":"Secondary","55":"Secondary"},
        "config":{"44":[55],"55":[55]}
    },
];

// IF s \\in voteQuorum THEN "Secondary" ELSE state[s]]


// /\\ \\A v \\in voteQuorum : CanVoteForConfig(v, i, currentTerm[i] + 1)
function mldr_init(){
    // TODO: Will again have to contend with set vs. list ordering issues eventually.
    testStateGen("mldr-init", specmldr1, mldrInitExpected, null);
}

function mldr_next(){
    let mldrNextExpected = [
        {   "currentTerm":{"44":0,"55":0},
            "state":{"44":"Secondary","55":"Secondary"},
            "config":{"44":[44],"55":[44]},
            "currentTerm'":{"44":1,"55":0},
            "state'":{"44":"Primary","55":"Secondary"},
            "config'":{"44":[44],"55":[44]}
        },
        {   "currentTerm":{"44":0,"55":0},
            "state":{"44":"Secondary","55":"Secondary"},
            "config":{"44":[55],"55":[55]},
            "currentTerm'":{"44":0,"55":1},
            "state'":{"44":"Secondary","55":"Primary"},
            "config'":{"44":[55],"55":[55]}
        },
        {   "currentTerm":{"44":0,"55":0},
            "state":{"44":"Secondary","55":"Secondary"},
            "config":{"44":[44,55],"55":[44,55]},
            "currentTerm'":{"44":1,"55":1},
            "state'":{"44":"Primary","55":"Secondary"},
            "config'":{"44":[44,55],"55":[44,55]}
        },
        {   "currentTerm":{"44":0,"55":0},
            "state":{"44":"Secondary","55":"Secondary"},
            "config":{"44":[44,55],"55":[44,55]},
            "currentTerm'":{"44":1,"55":1},
            "state'":{"44":"Secondary","55":"Primary"},
            "config'":{"44":[44,55],"55":[44,55]}
        },
    ];
    testStateGen("mldr-next", specmldr1, mldrInitExpected, mldrNextExpected);
}

function testTLCEquiv(testId, specName){
    let specStatesPath = `./specs/with_state_graphs/${specName}.json`;
    res = $.get(specStatesPath).then(data => {
        let specPath = `./specs/with_state_graphs/${specName}.tla`;
        testStateGraphEquiv(testId, data, specPath);
    });      
}

function record_literal_eval(){
    let spec = `---- MODULE record_literal_eval ----
    EXTENDS TLC, Naturals
    
    VARIABLE x

    Init == 
    \\/ x = [a |-> "v1", b |-> "v2"]
    \\/ x = [a |-> "v1", b |-> "v2", c |-> "v3"]
    Next == x' = x
    
    ====`;
    initExpected = [
        {"x": {a:"v1", b:"v2"}},
        {"x": {a:"v1", b:"v2", c: "v3"}}
    ];
    testStateGen("record_literal_eval", spec, initExpected, null);    
}

function simple5(){
    return testTLCEquiv("simple5");
}

tests = {
    "simple-spec1": simple_spec1,
    "simple-spec2": simple_spec2,
    "simple-spec3": simple_spec3,
    "simple-spec4": simple_spec4,
    "simple-spec4a": simple_spec4a,
    "simple-spec5": simple_spec5,
    "record_literal_eval": record_literal_eval,
    "simple-lockserver-nodefs": simple_lockserver_nodefs,
    "simple-lockserver-withdefs": simple_lockserver_withdefs,
    "mldr-init": mldr_init,
    "mldr-next": mldr_next,
    "simple5-tlc-equiv": (() => testTLCEquiv("simple5-tlc-equiv", "simple5")),
    "mldr-init-only-tlc-equiv": (() => testTLCEquiv("mldr-init-only-tlc-equiv", "mldr_init_only"))
}

const start = performance.now();

const urlSearchParams = new URLSearchParams(window.location.search);
const params = Object.fromEntries(urlSearchParams.entries());
const arg = params["test"];

// Allow URL arg to choose which test to run.
let testNames;
if(arg==="all" || arg === undefined){
    testNames = Object.keys(tests);
} else{
    testNames = [arg];
}

// Run the specified tests.
for(const name of testNames){
    console.log(`Running test '${name}'`);
    tests[name]();
}


// Measure test duration.
const duration = (performance.now() - start).toFixed(1);
console.log(`All tests ran in ${duration}ms`);
let durationDiv = document.getElementById("test-duration");
durationDiv.style="margin-top:25px;";
durationDiv.innerText = `All ${testNames.length} tests ran in ${duration}ms`;

})();