# How TLC Computes States

See *Specifying Systems* 14.2.6 for reference.

When TLC evaluates an invariant, it is calculating the invariant's value in the context of a given state. That is, under a particular assignment of values to variables. The result of this evaluation is either TRUE or FALSE. When TLC evaluates the initial predicate or the next state action, it is instead computing a set of states. For the initial predicate, it is the set of all possible initial states. For the next state action, it is the set of possible *successor* states from a given starting state.

Recall that a state is an assignment of values to variables. TLC computes the successors of a given state `s` by assigning to all unprimed variables their values in state `s`, assigning no values to the primed variables, and then evaluating the next-state action. TLC evaluates the next-state action as described in Section 14.2.2 (page 231), except for two differences:
- For disjunctions `A1 \/ ... \/ An`, TLC splits the computation into `n` separate evaluations, one for each subexpression. 
- For any variable `x`, if it evaluates an expression of the form `x' = e` when `x'` has not yet been assigned a value, then the evaluation yields the value `TRUE` and TLC assigns to `x'` the value obtained by evaluating the expression `e`.

An evaluation that completes and obtains the value `TRUE` finds the state determined by the values assigned to the primed variables. An evaluation stops, finding no states, if a conjunct evaluates to `FALSE`.

For computing initial states, TLC follows a similar procedure, but instead of starting from given values of unprimed variables and assigning values to the primed variables, it assignes values to the unprimed variables.

## Implementation Details

The evaluation of an initial state predicate/expression can be viewed as returning both a boolean value (`TRUE/FALSE`) as well as a set of possible states, i.e. assignments to variables that satisfy the initial state predicate. Whenever we evaluate a conjunction list 
```tla
Expr == A1 /\ ... /\ An
```
we want to compute the boolean value of each expression, and the value of `Expr` is then the conjunction of all of these boolean values. Similarly, for generating possible states, we start off with a set of currently generated (possibly partial) states, and for each of these, we go through each conjunction and evaluate it in the context of that partial state assignment, updating any assignments as necessary. For a disjunction 
```tla
Expr == A1 \/ ... \/ An
```
we split the evaluation into `n` branches. The overall boolean value of `Expr` is, similarly, the disjunction of the values of all `Ai` subformulas, but the set of possible states now becomes the union of the possible states generated by each subformula, where each subformula is given the current context to generate states from.

```javascript
expr_context = {
    // The currently computed 
    // value of an expression.
    "val": Val
    // The list of (possibly partial) states so far 
    // generated up to the current context
    // of this expression evaluation.
    "states": [State]
}
```
