# How the TLA+ Interpreter Evaluates Expressions

The evaluation of a TLA+ expression may produce either (1) a value or (2) a set of states along with a value. The first case is the simplest to handle, and deals with basic "constant level" expressions of TLA+ e.g. evaluating expressions like
```
2 + 3
{1,2,3} \cup {3,4}
Append(<<1,2>>, 5)
```
TLA+ expressions can also be evaluated in the context of initial state or next state generation, where the aim is not to evaluate an expression as a single value, but rather to generate a set of states satisfying the given TLA+ state (or action) predicate. 

### Initial State Generation

It is simplest to first consider initial state generation, since next state generation is not fundamentally different. Given a set of defined variables and a TLA+ formula, like
```tla
x = 1 \/ x = 2
```
the problem of initial state generation can be viewed as equivalent to the [satisfiability problem](https://en.wikipedia.org/wiki/Boolean_satisfiability_problem), or, more generally, a variant of a [constraint satisfaction problem](https://en.wikipedia.org/wiki/Constraint_satisfaction_problem) (CSP), where the variable domains are initially unknown. That is, the goal is to generate the set of all possible assignments to state variables that make the given formula true. In practice, only formulas that allow variables to range over finite domains can be handled, so we can assume that all variable domains are finite. 

The intuition behind the algorithm for state generation can be illustrated by focusing on a few simple examples. A key concept of the evaluation algorithm is that of an *evaluation context*, which is the term we use in our interpreter. Essentially, a context represents all of the state relevant to a current, in-progress state generation procedure, for a single branch of the evaluation computation. The evaluation function can be given the following signature, where it takes in a set of contexts and an expression, and returns a new set of contexts.
```
eval(set<Context>, expr) -> set<Context>
```

As an example, consider the task of generating all initial states satisfying the following TLA+ formula:

```
x = 1 \/ x = 2
```
Initially, we begin with a single, empty context, in which no state variables are assigned any values. 

```
eval({}, x = 1 \/ x = 2)
```

If we encounter a disjunction, during evaluation, then this splits our current computation into two new branches. In the above case, we would split the computation, and then be left with one new formula in each branch:

```
eval({}, x = 1 \/ x = 2)
    eval({}, x = 1)
    eval({}, x = 2)
```
Each of these sub-evaluations then both produce new contexts, since they both contains variable assignments

```
eval({}, x = 1 \/ x = 2) -> {{x=1}, {x=2}}
    eval({}, x = 1) -> {x=1}
    eval({}, x = 2) -> {x=2}
```

## Implementation Details

The evaluation of an initial state predicate/expression can be viewed as returning both a boolean value (`TRUE/FALSE`) as well as a set of possible states, i.e. assignments to variables that satisfy the initial state predicate. Whenever we evaluate a conjunction list 
```tla
Expr == A1 /\ ... /\ An
```
we want to compute the boolean value of each expression, and the value of `Expr` is then the conjunction of all of these boolean values. Similarly, for generating possible states, we start off with a set of currently generated (possibly partial) states, and for each of these, we go through each conjunction and evaluate it in the context of that partial state assignment, updating any assignments as necessary. For a disjunction 
```tla
Expr == A1 \/ ... \/ An
```
we split the evaluation into `n` branches. The overall boolean value of `Expr` is, similarly, the disjunction of the values of all `Ai` subformulas, but the set of possible states now becomes the union of the possible states generated by each subformula, where each subformula is given the current context to generate states from.

```javascript
expr_context = {
    // The currently computed 
    // value of an expression.
    "val": Val
    // The list of (possibly partial) states so far 
    // generated up to the current context
    // of this expression evaluation.
    "states": [State]
}
```
